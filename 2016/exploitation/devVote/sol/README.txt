This challenge was a kernel exploit challenge for a "voting machine" kernel module.

The module allowed you to add one to somewhere in a buffer of 256 bytes, but also had a function that let you temporarily write a byte somewhere in the buffer. The next call to that would write the old byte back.

Outline of intended solution:
- The bug is that this function does not check the bound on the buffer
- It will let you write to anywhere in a short range of the buffer.
- Since you can only write one byte, since the last gets replaced, we need a way to make a byte persistent.
- The first step is to write to the actual pointer that tracks the last write. This lets us force the last byte to be written somewhere else (although we can only change one byte of this address).
- There is a flag which enables a "consistency check" which does an expensive hash over the buffer.
    o We can toggle this on with the step above to cause this check to run
- Now that the check runs, we can request a large area to hash to cause the kernel thread to hang.
    o This introduces a race condition, since the actual byte write is done after the check.
- Spawning 4 threads/processes to write to the four bytes of the pointer lets us change it to an arbitrary location
    o However the last thread to start will dictate what byte gets written on the next call, which is not good since they all point to bytes in the pointer and not the arbitrary bytes we want.
    o So we can start a 5th thread that just stores the byte we want to write.
- Once all the threads finish their checks, we call the function again, and can now write one byte anywhere in writable memory.
- The intended way to use this was to write over core_pattern with something like |/tmp/a to run /tmp/a as root

