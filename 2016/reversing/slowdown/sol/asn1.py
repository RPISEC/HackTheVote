def modinv(a, m):
    """Applies egcd to find the modular inverse of @a modulo @m.
    e.g.
        >>> modinv(-2,3)
        2
    """
    # convert negative to positive if necessary
    a = a if a >= 0 else ((m-a) % m)

    gcd, x, y = egcd(a, m)
    if gcd != 1:
        return None  # modular inverse does not exist
    else:
        return x % m

asn1_format = """asn1=SEQUENCE:rsa_key

[rsa_key]
version=INTEGER:0
modulus=INTEGER:{}
pubExp=INTEGER:{}
privExp=INTEGER:{}
p=INTEGER:{}
q=INTEGER:{}
e1=INTEGER:{}
e2=INTEGER:{}
coeff=INTEGER:{}
"""
p = int('A6EFAC73B8E01AE84F76DF2658A031C5E0ADA990FBC57C961E6EF4D7A7BB97BC4CD088ACE28178FD94F13E2388301C7E16BB3347B0F6083DA0808948059BCCBBCD87FA3A062ADBD1645864832BA5A06FA55CDDC2F9BCF0F707049B6D5B73632295EAB5A93BBA4DBCAB63B1B95478927B45E3F9D6C50BFF3346B4A5D8AE5CD3A75D3FC9D85490BB2C415DC03AC33D14654F2C4B86B2CD1196010F012BFC459054C84897E5F8244AECE1FC2E4B708EDC54417E037A164003745C4967F7704B5FC890237D453CEA0395A3AD1A57D14FCF5D69BB5C5E278211F0423F2DFAA76CA05A340941283CFD94547792A17740B5AD83DEEA0A08CB9FDA745701D75A4C6AB3D9', 16)
q = int('3527DD2886FBC756DF629F6F4E3035454F71BEF44AA6FEC46AA33C3B4112D9BDB3A9DDED54143E7653B6F0BA30ED2A2C018A32498F96585414A64EF16DABC81F360F0E59C6158E03A9E805992020E86AD1DB1B9916AE65D4B6E440607AA1850EFCB3D8EFDC2D3E2B3B51ABD2E1B185AE30491FB436204177190AA24ECF1913D3C21DE084570E0557EC8F3E14972C59151EBEF31A9CD9581273A7A21B2CF5C0513E68E5726871581FED50BFB76C9DB894EE5C2782814A19050A2C03CE1593E583DD4023FA42244F440786799AB70F382F2B7E363400D6D0707BD1F21D76957666FD4E8A89F3496D1AB6560D809E8F5288B115C79E0067D6AE318AE895CC3A1033', 16)

def gen_asn1(p, q):
    n=p*q
    phi=(p-1)*(q-1)
    e=65537
    d=modinv(e, phi)
    e1=d % (p-1)
    e2=d % (q-1)
    coff=pow(q, p-2, p) # modinv with prime modulus
    return asn1_format.format(n,e,d,p,q,e1,e2,coff)

with open('privkey.asn1', 'wb') as f:
    f.write(gen_asn1(p,q))
